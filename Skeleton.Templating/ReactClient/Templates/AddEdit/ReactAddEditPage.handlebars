// generated by a tool
// common add/edit components
import { useEffect, useState } from 'react';
import { Formik, Field, Form, ErrorMessage, FormikErrors, getIn, FormikProps } from 'formik';
import * as queryString from 'query-string';
import {useLocation, useNavigate, useParams} from "react-router-dom";
import { ErrorControl } from '../../controls/error-control';
import {Button, FormControlLabel, FormHelperText, FormGroup, Grid, Rating, TextField, Typography, IconButton} from "@mui/material";
import SaveIcon from '@mui/icons-material/Save';
import {TriStateCheckbox} from "../../controls/TriStateCheckbox";
import Title from "../../controls/Title";
import { LoadingButton } from '@mui/lab';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { DateTimePicker } from '@mui/x-date-pickers/DateTimePicker';
import {useSnackbar} from "notistack";
import { motion, AnimatePresence } from "framer-motion";
import { useMutation, useQueryClient } from "@tanstack/react-query";
{{#if IsUpdate}}import { Loading } from '../../controls/loading';{{/if}}
{{#if HasAnyHtmlFields}}import RichContentEditor from "../../controls/RichTextEditor";{{/if}}
{{#if HasHelp}}
import { useHelp } from '../../help';
import HelpOutlineIcon from "@mui/icons-material/HelpOutline";
{{/if}}

// sub-components for {{cs_name Name}} 
import { {{cs_name Name}} } from './{{cs_name Name}}';
import { {{ClientApiInterfaceName}}, {{ClientApiTypeName}}, {{ClientApiTypeName}}QueryKeys } from './{{cml_case Name}}ApiClient';
import { {{cs_name Name}}Validate } from './{{cml_case Name}}Validate';
import {{cs_name Name}}{{OperationNameFriendly}}Rendering from './{{cml_case Name}}{{OperationNameFriendly}}Rendering';
{{#if CurrentOperation.UsesModel}}
import { {{ModelTypeName}} } from "./{{ModelTypeName}}";
{{/if}}
{{#each CurrentOperation.UserProvidedParameters}}
{{#if IsCustomTypeOrCustomArray}}
import { {{ResolvedTypescriptTypeUnderlying}} } from './{{ResolvedTypescriptTypeUnderlying}}'
{{/if}}
{{/each}}
{{#if IsUpdate}}
{{#if HasSelectAllType}}
import { {{cs_name SelectAllType.Name}} } from './{{cs_name SelectAllType.Name}}';
{{/if}}
{{/if}}
{{#if AssociateViaLink}}
    
// linking with other types    
import { linkedItem } from '../../linked-items';
{{#each LinkedDetails}}
import { {{LinkingType.ClientApiInterfaceName}}, {{LinkingType.ClientApiTypeName}} } from '../{{kb_case LinkingType.Name}}/{{cml_case LinkingType.Name}}ApiClient';
import { {{cs_name LinkingType.Name}}New } from '../{{kb_case LinkingType.Name}}/{{cs_name LinkingType.Name}}New';
{{/each}}
{{/if}}
{{#each CurrentOperation.ParameterReferenceTypes}}
import { {{cs_name Name}}Select } from '../{{kb_case Name}}/{{cml_case Name}}Select';
{{/each}}

export interface {{StateTypeName}} {
	{{#if CurrentOperation.UsesModel}}
    data: {{ModelTypeName}};
	{{#if IsUpdate}}
	fetched: {{cs_name SelectAllType.Name}} | null;
	{{/if}}
	{{else}}
	{{#each CurrentOperation.UserProvidedParameters}}
    {{cml_case Name}}: {{ResolvedTypescriptTypeUnderlying}} | null;
    {{/each}}
	{{/if}}
    visible: boolean;
    error: boolean;
	message?: string | null;
	{{#if IsUpdate}}
	loading: boolean;	
	{{/if}}
    linkedType? : {{#each CurrentOperation.EditableLinkingFields}} "{{ReferencesType.Name}}" | {{/each}} null;
    linkedId? : number | string | null;
}

export interface {{cs_name Name}}{{OperationNameFriendly}}Props {
	onSaved? (result: {{CurrentOperation.TypeScriptReturn}}) : void;
	title? : string;
	{{#if AssociateViaLink}}
	linkedType? : {{#each CurrentOperation.EditableLinkingFields}} "{{ReferencesType.Name}}" | {{/each}} null;
	linkedId? : number | string | null;
	{{/if}}
	{{#if IsUpdate}}
	id?: {{get_ts_type IdentityField.ClrType}} | null;
	{{/if}}
    {{#each CurrentOperation.EditableLinkingFields}}
    {{cml_case Name}}? : {{get_ts_type ClrType}} | null;
    {{/each}}
    api? : {{ClientApiInterfaceName}} | null;
    {{#if AssociateViaLink}}
    {{#each LinkedDetails}}
    {{cml_case LinkingType.Name}}Client? : {{LinkingType.ClientApiInterfaceName}} | null;
    {{/each}}
    {{/if}}
}

export const {{cs_name Name}}{{OperationNameFriendly}} = (props: {{cs_name Name}}{{OperationNameFriendly}}Props) : React.ReactElement => {

    const api: {{ClientApiInterfaceName}} = props.api ?? new {{ClientApiTypeName}}();
	const validation: {{cs_name Name}}Validate = new {{cs_name Name}}Validate();
	const rendering: {{cs_name Name}}{{OperationNameFriendly}}Rendering = new {{cs_name Name}}{{OperationNameFriendly}}Rendering();
    const location = useLocation();
    const locationState = location.state as unknown as {{StateTypeName}};
    const navigation = useNavigate();
    const {id} = useParams();
    const { enqueueSnackbar } = useSnackbar();
    const queryClient = useQueryClient();
    const save = useMutation({mutationFn: (fields : {{FormDataTypeName}}) => handleSubmit(fields) })
{{#if HasHelp}}
    const helptopic = "{{Name}}_{{cml_case OperationNameFriendly}}";
    const help = useHelp();
{{/if}}
    
{{#if IsUpdate}}
    const getProvidedData = () : {{ModelTypeName}} | null => {
        if (locationState && locationState.data){
            return locationState.data;
        }
        return null;
    }

    const getId = () : {{get_ts_type IdentityField.ClrType}} | null => {
        if (props.id) {
            return props.id;
        }
    
        // get from uri - {{IdentityField.ClrType}}
        if (id) {
            {{#if IdentityField.IsInt}} 
            return parseInt(id);
            {{else}}
            return id;    
            {{/if}}    
        }
    
        return null;
    }
{{/if}}

{{#each CurrentOperation.EditableLinkingFields}}
    const get{{cml_case Name}} = () : {{get_ts_type ClrType}} | null => {
        if (props.{{cml_case Name}}){
            return props.{{cml_case Name}};
        }
    
        if (locationState && locationState.linkedType == "{{ReferencesType.Name}}" && locationState.linkedId) {
            {{#if IsInt}}
                return +locationState.linkedId;
            {{else}}
                return locationState.linkedId;
            {{/if}}
        }
        const qry: any = queryString.default.parse(location.search);
        if (qry.{{cml_case Name}} && !Array.isArray(qry.{{cml_case Name}})) {
        {{#if IsInt}}
            return parseInt(qry.{{cml_case Name}});
        {{else}}
            return qry.{{cml_case Name}};
        {{/if}}
        }
    
        return null;
    }
{{/each}}

    {{#if IsUpdate}}
    const providedData = getProvidedData();
    {{/if}}

    const initialState = {
    {{#if CurrentOperation.UsesModel}}
        data: {{#if IsUpdate}}providedData ? providedData :{{/if}} {
        {{#each CurrentOperation.UserProvidedParameters}}
            {{#if RelatedTypeField.HasReferenceType}}
                {{#unless RelatedTypeField.ReferencesType.IsReferenceData}}
                    {{cml_case Name}}: get{{cml_case Name}}(),
                {{else}}
                    {{cml_case Name}}: null,
                {{/unless}}
            {{else}}
                {{cml_case Name}}: null,
            {{/if}}
        {{/each}}
        },
        {{#if IsUpdate}}
            fetched: null,
        {{/if}}
    {{else}}
        {{#each CurrentOperation.UserEditableParameters}}
            {{#if RelatedTypeField.HasReferenceType}}
                {{#unless RelatedTypeField.ReferencesType.IsReferenceData}}
                    {{cml_case Name}}: get{{cml_case Name}}(),
                {{else}}
                    {{cml_case Name}}: null,
                {{/unless}}
            {{else}}
                {{#if IsCustomTypeOrCustomArray}}
                    {{cml_case Name}}: {
                    {{#each ClientCustomType.Fields}}
                        {{#if HasReferenceType}}
                            {{#unless ReferencesType.IsReferenceData}}
                                {{cml_case Name}}: get{{cml_case Name}}(),
                            {{else}}
                                {{cml_case Name}}: null,
                            {{/unless}}
                        {{else}}
                            {{cml_case Name}}: null,
                        {{/if}}
                    {{/each}}
                    },
                {{else}}
                    {{cml_case Name}}: null,
                {{/if}}
            {{/if}}
        {{/each}}
    {{/if}}
    {{#if IsUpdate}}
        loading: providedData == null,
    {{/if}}
        error: false,
        visible: true,
    };
    
    const [state, setState] = useState<{{StateTypeName}}>(initialState);

    const goBack = () => {
        setState((prevState: {{StateTypeName}}) => ({ ...prevState, visible: false }));
        setTimeout(() => { navigation(-1) }, 250); // time for exit animation to run 
    }

	const cancelSave = (event: any) => {
	    goBack();
    }

	{{#if IsUpdate}}
	function getItemDetails(id: {{get_ts_type IdentityField.ClrType}}) {
        api.selectForDisplayById(id).then(data => {
            if (data) {
				const newData = {
					{{#each CurrentOperation.UserProvidedParameters}}
					{{#if IsFile}}
					{{cml_case Name}}: null,
					{{else}}
					{{cml_case Name}}: data.{{cml_case Name}},
					{{/if}}
					{{/each}}				
				}
				setState((prevState) => { return {...prevState, data: newData, loading: false, fetched: data! }});								
			} else {
				setState((prevState) => { return {...prevState, loading: false, error: true, message: "Item Not Found" }});				
			}            
        }).catch(err => {
            setState((prevState) => { return {...prevState, loading: false, error: true, message: err.message }});
        });
    }

    useEffect(() => {
        const idToFetch = getId();
        if (idToFetch){
            getItemDetails(idToFetch);
        }
    }, [props.id, id])
	{{/if}}

    {{#if AssociateViaLink}}
	const createLinkedItemAssociation = (id: number | string) => {
		// creation via location from a link, or via linkedId and linkedType properties
        var linked : [string, number | string] | null = null;
        if (props.linkedId && props.linkedType){
            linked = [props.linkedType, props.linkedId];
        } else {
            linked = linkedItem(locationState);			
        }

        if (linked) {
            {{#each LinkedDetails}}
            if (linked[0] == "{{Name}}") {
                var {{cml_case LinkingType.Name}}Client = props.{{cml_case LinkingType.Name}}Client ?? new {{LinkingType.ClientApiTypeName}}();
                var {{cml_case LinkingType.Name}}ToAdd: {{cs_name LinkingType.Name}}New = { {{cml_case LinkingTypeIdField.Name}}: linked[1] as {{get_ts_type LinkingTypeIdField.ClrType}}, {{cml_case CurrentTypeIdField.Name}}: id as {{get_ts_type CurrentTypeIdField.ClrType}} };
                {{cml_case LinkingType.Name}}Client.insert({{cml_case LinkingType.Name}}ToAdd);
            }
            {{/each}}
        }		
    }
	{{/if}}

    const invalidateCaches = () => {
        {{ClientApiTypeName}}QueryKeys.invalidateAll(queryClient);
    }

	{{#if IsAttachment}}
    const handleSubmit = async (fields : {{FormDataTypeName}}) : Promise<void> => {
		const formData = new FormData();
		{{#each CurrentOperation.ClientSuppliedFields}}
		if (fields.{{NameWithPathSafeCamelCase}}){
			{{#if Field.RelatedTypeField.IsFile}}
			formData.append('{{cml_case Name}}',fields.{{NameWithPathCamelCase}});		
			{{else}}
			formData.append('{{cml_case Name}}',fields.{{NameWithPathCamelCase}}.toString());		
			{{/if}}
		}
		{{/each}}
        try {
		    const data = await api.{{cml_case OperationName}}(formData);
			{{#unless IsUpdate}}
			if (data) {
                createLinkedItemAssociation(data);
            }
			{{/unless}}
            enqueueSnackbar('{{HumanizedName}} saved', {variant: 'success'});
            invalidateCaches();
			if (props.onSaved && data) {
                props.onSaved(data);
            } else {
                goBack();
            }
        }
        catch (err) {
            enqueueSnackbar('Error saving {{HumanizedName}}. ' + err, {variant: 'error'});
            throw err;
        }
    }
	{{else}}
        const handleSubmit = async (fields : {{FormDataTypeName}}) : Promise<void> => {
        {{#if CurrentOperation.HasCustomType}}
        console.log(fields);
        {{/if}}
        try {
		{{#if CurrentOperation.UsesModel}}
		    const data = await api.{{cml_case OperationName}}(fields);
        {{else}}
            const data = await api.{{cml_case OperationName}}({{#each CurrentOperation.UserProvidedParameters}}{{#if IsCustomArrayType}}[fields.{{cml_case Name}}]{{else}}fields.{{cml_case Name}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}}); 
		{{/if}}
			{{#if AssociateViaLink}}
			if (data) {
                createLinkedItemAssociation(data);
            }
			{{/if}}
            enqueueSnackbar('{{HumanizedName}} saved', {variant: 'success'});
            invalidateCaches();
			if (props.onSaved && data) {
                props.onSaved(data);
            } else {
                goBack();
            }
        }
        catch (err) {
            enqueueSnackbar('Error saving {{HumanizedName}}. ' + err, {variant: 'error'});
            throw err;
        }
    }
	{{/if}}

	const validate = (newState: {{FormDataTypeName}}): FormikErrors<{{FormDataTypeName}}> => {
        return validation.validate{{cs_name CurrentOperation.BareName}}(newState);
    }

    const hasError = (key: string, formik: FormikProps<Readonly<{{FormDataTypeName}}>>) : boolean => {
        return getIn(formik.errors, key) && getIn(formik.touched, key);
    }

    const errorMessage = (key: string, formik: FormikProps<Readonly<{{FormDataTypeName}}>>) : string | null =>{
        if (hasError(key, formik)){
            return getIn(formik.errors, key);
        }
        return null;
    }

    const renderTitle = () : React.ReactElement | null => {
    {{#if HasHelp}}
        const helpButton = (<IconButton onClick={e => help.showHelp(helptopic)}><HelpOutlineIcon color="primary" /></IconButton>);
        if (props.title){
            return <Title>{props.title}{helpButton}</Title>;
        }

        const customTitle = rendering.renderCustomTitle(state);
        if (customTitle){
            return customTitle;
        }

        return <Title>{{OperationNameFriendly}} {{hmn Name}}{helpButton}</Title>;            
    {{else}}
        if (props.title){
            return <Title>{props.title}</Title>;
        }

        const customTitle = rendering.renderCustomTitle(state);
        if (customTitle){
            return customTitle;
        }

        return <Title>{{OperationNameFriendly}} {{hmn Name}}</Title>;
    {{/if}}
    }

        return (
        <AnimatePresence> {state.visible ?
        <motion.div initial={ { opacity: 0, x: -1000 } }
                    animate={ { opacity: 1, x: 0 } }
                    exit={ { opacity: 0, x: -1000 } }>            
		<Formik {{#if IsUpdate}}enableReinitialize{{/if}} initialValues={ {{CurrentOperation.StatePath}} } onSubmit={save.mutate} validate={validate}>
            {formik => (
			<div>
                {renderTitle()}
				{{#if IsUpdate}} { state.loading ? <Loading /> : null } {{/if}}
				{ state.error ? <ErrorControl message={state.message ? state.message : ""} /> : null }
                <Form autoComplete="off">
                    <Grid container spacing={2}>
					{{#each CurrentOperation.UserInputFields}}											
						{{#if IsBoolean}}
                        <Grid item xs={12}>
                            <FormGroup>
                                <FormControlLabel control={<TriStateCheckbox id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" checked={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={(e:any) => {
                                formik.setFieldValue('{{NameWithPathCamelCase}}', e.target.checked);
                                }} />} label="{{#if Field.IsRequired}}*{{/if}}{{hmn Field}}" />
                                <FormHelperText error={true}>
                                    <ErrorMessage name="{{NameWithPathCamelCase}}" />
                                </FormHelperText>
                            </FormGroup>
                        </Grid>
                        {{else}}
                        <Grid item xs={12}>
							{{#if Field.HasReferenceType}}
							<Field id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" component={ {{cs_name Field.ReferencesType.Name}}Select } value={ {{../CurrentOperation.StatePath}}?.{{NameWithPathSafeCamelCase}} } label="{{hmn Field}}" error={ hasError('{{NameWithPathCamelCase}}', formik)} {{#unless Field.ReferencesType.IsReferenceData}} readonly={get{{cml_case Name}}() != null} {{/unless}} />
                            <FormHelperText error={true}>
                                <ErrorMessage name="{{NameWithPathCamelCase}}" />
                            </FormHelperText>
                            {{else}}
								{{#if IsDateTime}}
                                {{#if IsDate}}<DatePicker {{else}}<DateTimePicker {{/if}}
                                slotProps={ {
                                    textField: {
                                    variant: "outlined",
                                    id: "{{NameWithPathCamelCase}}",
                                    name: "{{NameWithPathCamelCase}}",
                                    error: hasError('{{NameWithPathCamelCase}}', formik),
                                    {{#if Field.IsRequired}}required:true,{{/if}}
                                    },
                                    actionBar: {
                                        actions: ['clear', 'today']
                                    },
                                } }                                    
                                label="{{hmn Field}}"
                                value={ formik.values.{{NameWithPathSafeCamelCase}} }
                                onChange={(newValue) => {
                                    formik.setFieldValue("{{NameWithPathCamelCase}}", newValue);
                                }}
                            />                                                                         
                            <FormHelperText error={true}>
                                <ErrorMessage name="{{NameWithPathCamelCase}}" />
                            </FormHelperText>
                                {{else}}
									{{#if IsLargeTextContent}}
                                <TextField minRows={4} maxRows={8} fullWidth id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur} label="{{hmn Field}}" {{#if Field.IsRequired}}required={true}{{/if}}  type="{{input_type ClrType}}" error={ hasError('{{NameWithPathCamelCase}}', formik)} placeholder="Enter {{hmn Name}}" multiline={true} helperText={ errorMessage('{{NameWithPathCamelCase}}', formik)} />
                                    {{else}}
									{{#if IsFile}}
								<input hidden type="file" id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" onChange={(event: any) => {
                                        formik.setFieldValue("{{NameWithPathCamelCase}}", event.currentTarget.files[0]);
                                }} />
                                <label htmlFor="{{NameWithPathCamelCase}}">
                                    <Button variant="contained" component="span" color="primary">
                                        Choose {{hmn Name}}
                                    </Button>
                                    {formik.values.{{NameWithPathSafeCamelCase}}?.name}
                                </label>
                                <FormHelperText error={true}>
                                    <ErrorMessage name="{{NameWithPathCamelCase}}" />
                                </FormHelperText>
                                    {{else}}
										{{#if IsRating}}
								<Rating id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur}/>
                                <FormHelperText error={true}>
                                    <ErrorMessage name="{{NameWithPathCamelCase}}" />
                                </FormHelperText>
                                        {{else}}
                                            {{#if IsColor}}
                                <FormGroup>
                                    <FormControlLabel control={<Field id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" type="color" className={'color-input' + (getIn(formik.errors, '{{NameWithPathCamelCase}}') && getIn(formik.touched, '{{NameWithPathCamelCase}}') ? ' is-invalid' : '')} placeholder="Enter {{hmn Name}}" />} label="{{#if Field.IsRequired}}*{{/if}}{{hmn Field}}" />
                                    <FormHelperText error={true}>
                                        <ErrorMessage name="{{NameWithPathCamelCase}}" />
                                    </FormHelperText>
                                </FormGroup>
                                            {{else}}
                                                {{#if IsHtml}}
                                <RichContentEditor value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={(val) => formik.setFieldValue("{{NameWithPathCamelCase}}", val)} placeholder={'Enter {{hmn Name}}'} />
										        {{else}}
								<TextField id="{{NameWithPathCamelCase}}" fullWidth name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur} label="{{hmn Field}}" {{#if Field.IsRequired}}required={true}{{/if}}  type="{{input_type ClrType}}" error={ hasError('{{NameWithPathCamelCase}}', formik)} helperText={ errorMessage('{{NameWithPathCamelCase}}', formik)} placeholder="Enter {{hmn Name}}" />                                
                                                {{/if}}
                                            {{/if}}
                                        {{/if}}
									{{/if}}
									{{/if}}
								{{/if}}
							{{/if}}
                        </Grid>
                        {{/if}}						
					{{/each}}
                        <Grid item xs={12}>
                            <Grid container spacing={2} justifyContent="flex-end">
                                <Grid item>
                                    <Button variant="outlined" sx={ {width:"100px"} } onClick={cancelSave}>Cancel</Button>
                                </Grid>
                                <Grid item>
                                    <LoadingButton loading={save.isPending} loadingPosition="start" startIcon={<SaveIcon />} disabled={save.isPending} color="secondary" sx={ {width:"100px"} } variant="contained" type="submit">Save</LoadingButton>
                                </Grid>
                            </Grid>
                        </Grid>  
                    </Grid>
                </Form>
            </div>
			)}
        </Formik></motion.div> : null }
        </AnimatePresence>
        );
}