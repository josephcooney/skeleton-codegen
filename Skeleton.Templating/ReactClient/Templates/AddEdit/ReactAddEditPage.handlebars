// generated by a tool
// common add/edit components
import React, { Component } from 'react';
import { Formik, Field, Form, ErrorMessage, FormikErrors, getIn, FormikProps } from 'formik';
import * as queryString from 'query-string';
import { Location, NavigateFunction } from 'react-router';
import { ErrorControl } from '../../controls/error-control';
import {Button, FormControlLabel, FormHelperText, FormGroup, Grid, Rating, TextField, Typography} from "@mui/material";
import {TriStateCheckbox} from "../../controls/TriStateCheckbox";
import Title from "../../controls/Title";
import { DateTimePicker, DatePicker } from '@mui/lab';
import {OptionsObject, SnackbarKey, SnackbarMessage} from 'notistack';
import { motion, AnimatePresence } from "framer-motion";
{{#if IsUpdate}}import { Loading } from '../../controls/loading';{{/if}}

// sub-components for {{cs_name Name}} 
import { {{cs_name Name}} } from './{{cs_name Name}}';
import { {{ClientApiInterfaceName}}, {{ClientApiTypeName}} } from './{{cml_case Name}}ApiClient';
import { {{cs_name Name}}Validate } from './{{cml_case Name}}Validate';
import {{cs_name Name}}{{OperationNameFriendly}}Rendering from './{{cml_case Name}}{{OperationNameFriendly}}Rendering';
{{#if CurrentOperation.UsesModel}}
import { {{cs_name Name}}{{OperationName}}Model } from "./{{cs_name Name}}{{OperationName}}Model";
{{/if}}
{{#each CurrentOperation.UserProvidedParameters}}
{{#if IsCustomTypeOrCustomArray}}
import { {{ResolvedTypescriptTypeUnderlying}} } from './{{ResolvedTypescriptTypeUnderlying}}'
{{/if}}
{{/each}}
{{#if IsUpdate}}
{{#if HasSelectAllType}}
import { {{cs_name SelectAllType.Name}} } from './{{cs_name SelectAllType.Name}}';
{{/if}}
{{/if}}
{{#if AssociateViaLink}}
    
// linking with other types    
import { linkedItem } from '../../linked-items';
{{#each LinkedDetails}}
import { {{LinkingType.ClientApiInterfaceName}}, {{LinkingType.ClientApiTypeName}} } from '../{{kb_case LinkingType.Name}}/{{cml_case LinkingType.Name}}ApiClient';
import { {{cs_name LinkingType.Name}}New } from '../{{kb_case LinkingType.Name}}/{{cs_name LinkingType.Name}}New';
{{/each}}
{{/if}}
{{#each CurrentOperation.ParameterReferenceTypes}}
import { {{cs_name Name}}Select } from '../{{kb_case Name}}/{{cml_case Name}}Select';
{{/each}}

export interface {{StateTypeName}} {
	{{#if CurrentOperation.UsesModel}}
    data: {{ModelTypeName}};
	{{#if IsUpdate}}
	fetched: {{cs_name SelectAllType.Name}} | null;
	{{/if}}
	{{else}}
	{{#each CurrentOperation.UserProvidedParameters}}
    {{cml_case Name}}: {{ResolvedTypescriptTypeUnderlying}} | null;
    {{/each}}
	{{/if}}
    visible: boolean;
    error: boolean;
	message?: string | null;
	{{#if IsUpdate}}
	loading: boolean;	
	{{/if}}
}

export interface I{{cs_name Name}}{{OperationNameFriendly}}Props {
	navigation? : NavigateFunction;
	onSaved? (result: {{CurrentOperation.TypeScriptReturn}}) : void; 
	location? : any; // TODO - need to change this to Location<T> - not quite sure how to define T
	title? : string;
    enqueueSnackbar? (message: SnackbarMessage, options?: (OptionsObject | undefined)) : void;
    closeSnackbar? (key?: (SnackbarKey | undefined)) : void;
	{{#if AssociateViaLink}}
	linkedType? : string;
	linkedId? : number | string | null;
	{{/if}}
	{{#if IsUpdate}}
	id?: {{get_ts_type IdentityField.ClrType}} | null;
	match?: any;
	{{/if}}
    {{#each CurrentOperation.EditableLinkingFields}}
    {{cml_case Name}}? : {{get_ts_type ClrType}} | null;
    {{/each}}
    api? : {{ClientApiInterfaceName}} | null;
    {{#each LinkedDetails}}
    {{cml_case LinkingType.Name}}Client? : {{LinkingType.ClientApiInterfaceName}} | null;
    {{/each}}
}

export class {{cs_name Name}}{{OperationNameFriendly}} extends Component<I{{cs_name Name}}{{OperationNameFriendly}}Props,{{StateTypeName}}> {

    private api: {{ClientApiInterfaceName}} = this.props.api ? this.props.api : new {{ClientApiTypeName}}();
	private validation: {{cs_name Name}}Validate = new {{cs_name Name}}Validate();
	private rendering: {{cs_name Name}}{{OperationNameFriendly}}Rendering = new {{cs_name Name}}{{OperationNameFriendly}}Rendering();
	private qry: any = this.props && this.props.location ? queryString.parse(this.props.location.search) : null;

    constructor(props: I{{cs_name Name}}{{OperationNameFriendly}}Props) {
        super(props);
		{{#if IsUpdate}}
		var providedData = this.getProvidedData();
		{{/if}}

        this.state = {
			{{#if CurrentOperation.UsesModel}}			
			data: {{#if IsUpdate}}providedData ? providedData :{{/if}} {
				{{#each CurrentOperation.UserProvidedParameters}}
				{{#if RelatedTypeField.HasReferenceType}}
					{{#unless RelatedTypeField.ReferencesType.IsReferenceData}}
				{{cml_case Name}}: this.{{cml_case Name}},
					{{else}}
				{{cml_case Name}}: null,
					{{/unless}}
				{{else}}
				{{cml_case Name}}: null,
				{{/if}}
				{{/each}}			
			},
			{{#if IsUpdate}}
			fetched: null,
			{{/if}}
			{{else}}
			{{#each CurrentOperation.UserEditableParameters}}
			{{#if RelatedTypeField.HasReferenceType}}
			{{#unless RelatedTypeField.ReferencesType.IsReferenceData}}
			{{cml_case Name}}: this.{{cml_case Name}},
			{{else}}
			{{cml_case Name}}: null,
			{{/unless}}
			{{else}}
                {{#if IsCustomTypeOrCustomArray}}
            {{cml_case Name}}: {
                    {{#each ClientCustomType.Fields}}
                        {{#if HasReferenceType}}
                            {{#unless ReferencesType.IsReferenceData}}
                {{cml_case Name}}: this.{{cml_case Name}},
                            {{else}}
                {{cml_case Name}}: null,
                            {{/unless}}
                        {{else}}            
                {{cml_case Name}}: null,
                        {{/if}}    
                    {{/each}}   
            },
                {{else}}
             {{cml_case Name}}: null,
                {{/if}}
			{{/if}}
			{{/each}}
			{{/if}}
			{{#if IsUpdate}}
			loading: providedData == null,
			{{/if}}
			error: false,
            visible: true
		};

		this.cancelSave = this.cancelSave.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
		this.validate = this.validate.bind(this);
    }

    goBack(){
        const nav = this.props.navigation;
        if (nav) {
            this.setState((prevState: {{StateTypeName}}) => ({ ...prevState, visible: false }));
            setTimeout(() => { nav(-1) }, 250); // time for exit animation to run
        }
    }

	cancelSave(event: any){
	    this.goBack();
    }

    {{#each CurrentOperation.EditableLinkingFields}}
    get {{cml_case Name}}() : {{get_ts_type ClrType}} | null {
        if (this.props.{{cml_case Name}}){
            return this.props.{{cml_case Name}};
        }

        if (this.props.location.state && this.props.location.state.linkedType == "{{cml_case ReferencesType.Name}}") {
            return this.props.location.state.linkedId;
        }

        if (this.qry.{{cml_case Name}} && !Array.isArray(this.qry.{{cml_case Name}})) {
        {{#if IsInt}}
            return parseInt(this.qry.{{cml_case Name}});
        {{else}}
            return this.qry.{{cml_case Name}};
        {{/if}}
        }

        return null;
    }
	{{/each}}

	{{#if IsUpdate}}
	getProvidedData() : {{ModelTypeName}} | null {
		if (this.props.location.state && this.props.location.state.data){
			return this.props.location.state.data;
		}
		return null;
	}

	getId() : {{get_ts_type IdentityField.ClrType}} | null {
		if (this.props.id) {
			return this.props.id;
		}

		// get from uri
		if (this.props.match) {
			const { id } = this.props.match.params;
			if (id) {
				return id;
			}		
		}

		return null;
	}

	componentDidUpdate(): void {
        var id = this.getId();
		if (id && (id != this.state.data.id)) {
            this.getItemDetails(id);
        }
    }

	componentDidMount(): void {
        var id = this.getId();
		if (id && (id != this.state.data.id)) {
            this.getItemDetails(id);
        }
    }
	{{/if}}

	{{#if IsAttachment}}
    handleSubmit(fields : any) {
		var formData = new FormData();
		{{#each CurrentOperation.ClientSuppliedFields}}
		if (fields.{{NameWithPathCamelCase}}){
			{{#if Field.RelatedTypeField.IsFile}}
			formData.append('{{cml_case Name}}',fields.{{NameWithPathCamelCase}});		
			{{else}}
			formData.append('{{cml_case Name}}',fields.{{NameWithPathCamelCase}}.toString());		
			{{/if}}
		}
		{{/each}}
		this.api.{{cml_case OperationName}}(formData).then(data => {
			{{#unless IsUpdate}}
			if (data.parsedBody) {
                this.createLinkedItemAssociation(data.parsedBody);
            }
			{{/unless}}
            this.props.enqueueSnackbar?.('{{HumanizedName}} saved', {variant: 'success'});
			if (this.props.onSaved && data.parsedBody) {
                this.props.onSaved(data.parsedBody);
            } else {
                this.goBack();
            }
        }).catch(err => {
            this.props.enqueueSnackbar?.('Error saving {{HumanizedName}}. ' + err, {variant: 'error'});
            err.text().then((value: string) => {     
                this.setState({ error: true, message: value });
            });
        });
    }
	{{else}}
    handleSubmit(fields : any) {
        {{#if CurrentOperation.HasCustomType}}
        console.log(fields);
        {{/if}}
		{{#if CurrentOperation.UsesModel}}
		this.api.{{cml_case OperationName}}(fields).then(data => {
        {{else}}
            this.api.{{cml_case OperationName}}({{#each CurrentOperation.UserProvidedParameters}}{{#if IsCustomArrayType}}[fields.{{cml_case Name}}]{{else}}fields.{{cml_case Name}}{{/if}}{{#unless @last}}, {{/unless}}{{/each}}).then(data => { 
		{{/if}}
			{{#if AssociateViaLink}}
			if (data.parsedBody) {
                this.createLinkedItemAssociation(data.parsedBody);
            }
			{{/if}}
            this.props.enqueueSnackbar?.('{{HumanizedName}} saved', {variant: 'success'});
			if (this.props.onSaved && data.parsedBody) {
                this.props.onSaved(data.parsedBody);
            } else {
                this.goBack();
            }
        }).catch(err => {
            this.props.enqueueSnackbar?.('Error saving {{HumanizedName}}. ' + err, {variant: 'error'});
            err.text().then((value: string) => {
                this.setState({ error: true, message: value });
            });
        });
    }
	{{/if}}

	validate(state: {{FormDataTypeName}}): FormikErrors<{{FormDataTypeName}}> {
        return this.validation.validate{{cs_name CurrentOperation.BareName}}(state);
    }

	{{#if AssociateViaLink}}
	createLinkedItemAssociation(id: number | string) {
		// creation via location from a link, or via linkedId and linkedType properties
        if (this.props.location || (this.props.linkedId && this.props.linkedType)) {
			
			var linked : [string, number | string] | null = null;
			if (this.props.linkedId && this.props.linkedType){
				linked = [this.props.linkedType, this.props.linkedId];
			} else {
				linked = linkedItem(this.props.location.state);			
			}

			if (linked) {
				{{#each LinkedDetails}}
				if (linked[0] == "{{Name}}") {
					var {{cml_case LinkingType.Name}}Client = this.props.{{cs_name LinkingType.Name}}Client ? this.props.{{cs_name LinkingType.Name}}Client : new {{LinkingType.ClientApiTypeName}}();
					var {{cml_case LinkingType.Name}}ToAdd: {{cs_name LinkingType.Name}}New = { {{cml_case LinkingTypeIdField.Name}}: linked[1] as {{get_ts_type LinkingTypeIdField.ClrType}}, {{cml_case CurrentTypeIdField.Name}}: id as {{get_ts_type CurrentTypeIdField.ClrType}} };
					{{cml_case LinkingType.Name}}Client.insert({{cml_case LinkingType.Name}}ToAdd);
				}
				{{/each}}
			}		
		}
    }
	{{/if}}

    hasError(key: string, formik: FormikProps<Readonly<{{FormDataTypeName}}>>) : boolean{
        return getIn(formik.errors, key) && getIn(formik.touched, key);
    }

    errorMessage (key: string, formik: FormikProps<Readonly<{{FormDataTypeName}}>>) : string | null{
        if (this.hasError(key, formik)){
            return getIn(formik.errors, key);
        }
        return null;
    }

    render() {
        return (
        <AnimatePresence> {this.state.visible ?
        <motion.div initial={ { opacity: 0, x: -1000 } }
                    animate={ { opacity: 1, x: 0 } }
                    exit={ { opacity: 0, x: -1000 } }>            
		<Formik {{#if IsUpdate}}enableReinitialize{{/if}} initialValues={ {{CurrentOperation.StatePath}} } onSubmit={this.handleSubmit} validate={this.validate}>
            {formik => (
			<div>
                {this.renderTitle()}
				{{#if IsUpdate}} { this.state.loading ? <Loading /> : null } {{/if}}
				{ this.state.error ? <ErrorControl message={this.state.message ? this.state.message : ""} /> : null }
                <Form autoComplete="off">
                    <Grid container spacing={2}>
					{{#each CurrentOperation.UserInputFields}}											
						{{#if IsBoolean}}
                        <Grid item xs={12}>
                            <FormGroup>
                                <FormControlLabel control={<TriStateCheckbox id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" checked={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={(e:any) => {
                                formik.setFieldValue('{{NameWithPathCamelCase}}', e.target.checked);
                                }} />} label="{{#if Field.IsRequired}}*{{/if}}{{hmn Field}}" />
                                <FormHelperText error={true}>
                                    <ErrorMessage name="{{NameWithPathCamelCase}}" />
                                </FormHelperText>
                            </FormGroup>
                        </Grid>
                        {{else}}
                        <Grid item xs={12}>
							{{#if Field.HasReferenceType}}
							<Field id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" component={ {{cs_name Field.ReferencesType.Name}}Select } value={ {{../CurrentOperation.StatePath}}?.{{NameWithPathSafeCamelCase}} } label="{{hmn Field}}" error={ this.hasError('{{NameWithPathCamelCase}}', formik)} {{#unless Field.ReferencesType.IsReferenceData}} readonly={this.{{cml_case Name}} != null} {{/unless}} />
                            <FormHelperText error={true}>
                                <ErrorMessage name="{{NameWithPathCamelCase}}" />
                            </FormHelperText>
                            {{else}}
								{{#if IsDateTime}}
                                    {{#if IsDate}}
                            <DatePicker 
                                renderInput={(props) => <TextField id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" onBlur={formik.handleBlur} {{#if Field.IsRequired}}required={true}{{/if}} error={ this.hasError('{{NameWithPathCamelCase}}', formik)} {...props} />}
                                label="{{hmn Field}}"
                            {{#unless Field.IsRequired}}
                                clearable={true}
                                clearText="clear"
                            {{/unless}}
                                value={ formik.values.{{NameWithPathSafeCamelCase}} }
                                onChange={(newValue) => {
                                    formik.setFieldValue("{{NameWithPathCamelCase}}", newValue);
                                }}
                            />
                                    {{else}}
                            <DateTimePicker
                                renderInput={(props) => <TextField id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" onBlur={formik.handleBlur} {{#if Field.IsRequired}}required={true}{{/if}} error={ this.hasError('{{NameWithPathCamelCase}}', formik)} {...props} />}
                                label="{{hmn Field}}"
                            {{#unless Field.IsRequired}}
                                clearable={true}
                                clearText="clear"
                            {{/unless}}
                                value={ formik.values.{{NameWithPathSafeCamelCase}} }
                                onChange={(newValue) => {
                                    formik.setFieldValue("{{NameWithPathCamelCase}}", newValue);
                                }}
                            />                                        
                                    {{/if}}
                            <FormHelperText error={true}>
                                <ErrorMessage name="{{NameWithPathCamelCase}}" />
                            </FormHelperText>
                                {{else}}
									{{#if IsLargeTextContent}}
                                <TextField minRows={4} maxRows={8} fullWidth id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur} label="{{hmn Field}}" {{#if Field.IsRequired}}required={true}{{/if}}  type="{{input_type ClrType}}" error={ this.hasError('{{NameWithPathCamelCase}}', formik)} placeholder="Enter {{hmn Name}}" multiline={true} helperText={ this.errorMessage('{{NameWithPathCamelCase}}', formik)} />
                                    {{else}}
									{{#if IsFile}}
								<input hidden type="file" id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" onChange={(event: any) => {
                                        formik.setFieldValue("{{NameWithPathCamelCase}}", event.currentTarget.files[0]);
                                }} />
                                <label htmlFor="{{NameWithPathCamelCase}}">
                                    <Button variant="contained" component="span" color="primary">
                                        Choose {{hmn Name}}
                                    </Button>
                                    {formik.values.{{NameWithPathSafeCamelCase}}?.name}
                                </label>
                                <FormHelperText error={true}>
                                    <ErrorMessage name="{{NameWithPathCamelCase}}" />
                                </FormHelperText>
                                    {{else}}
										{{#if IsRating}}
								<Rating id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur}/>
                                <FormHelperText error={true}>
                                    <ErrorMessage name="{{NameWithPathCamelCase}}" />
                                </FormHelperText>
                                        {{else}}
                                            {{#if IsColor}}
                                <FormGroup>
                                    <FormControlLabel control={<Field id="{{NameWithPathCamelCase}}" name="{{NameWithPathCamelCase}}" type="color" className={'color-input' + (getIn(formik.errors, '{{NameWithPathCamelCase}}') && getIn(formik.touched, '{{NameWithPathCamelCase}}') ? ' is-invalid' : '')} placeholder="Enter {{hmn Name}}" />} label="{{#if Field.IsRequired}}*{{/if}}{{hmn Field}}" />
                                    <FormHelperText error={true}>
                                        <ErrorMessage name="{{NameWithPathCamelCase}}" />
                                    </FormHelperText>
                                </FormGroup>
										    {{else}}
								<TextField id="{{NameWithPathCamelCase}}" fullWidth name="{{NameWithPathCamelCase}}" value={ formik.values.{{NameWithPathSafeCamelCase}} } onChange={formik.handleChange} onBlur={formik.handleBlur} label="{{hmn Field}}" {{#if Field.IsRequired}}required={true}{{/if}}  type="{{input_type ClrType}}" error={ this.hasError('{{NameWithPathCamelCase}}', formik)} helperText={ this.errorMessage('{{NameWithPathCamelCase}}', formik)} placeholder="Enter {{hmn Name}}" />                                
                                            {{/if}}    
                                        {{/if}}
									{{/if}}
									{{/if}}
								{{/if}}
							{{/if}}
                        </Grid>
                        {{/if}}						
					{{/each}}
                        <Grid item xs={12}>
                            <Grid container spacing={2} justifyContent="flex-end">
                                <Grid item>
                                    <Button variant="outlined" sx={ {width:"100px"} } onClick={this.cancelSave}>Cancel</Button>
                                </Grid>
                                <Grid item>
                                    <Button color="primary" sx={ {width:"100px"} } variant="contained" type="submit">Save</Button>
                                </Grid>
                            </Grid>
                        </Grid>  
                    </Grid>
                </Form>
            </div>
			)}
        </Formik></motion.div> : null }
        </AnimatePresence>
        );
    }

	renderTitle() : JSX.Element | null {
		if (this.props.title){
			return <Title>{this.props.title}</Title>;
		}
		
		var customTitle = this.rendering.renderCustomTitle(this.state);
		if (customTitle){
			return customTitle;
		}

		return <Title>{{OperationNameFriendly}} {{hmn Name}}</Title>;
	}

	{{#if IsUpdate}}
	async getItemDetails(id: {{get_ts_type IdentityField.ClrType}}) {
        await this.api.selectForDisplayById(id).then(data => {
            if (data.parsedBody) {
				const newData = {
					{{#each CurrentOperation.UserProvidedParameters}}
					{{#if IsFile}}
					{{cml_case Name}}: null,
					{{else}}
					{{cml_case Name}}: data.parsedBody.{{cml_case Name}},
					{{/if}}
					{{/each}}				
				}
				this.setState({ data: newData, loading: false, fetched: data.parsedBody });								
			} else {
				this.setState({ loading: false, error: true, message: "Item Not Found" });				
			}            
        }).catch(err => {
            this.setState({ loading: false, error: true, message: err.message });
        });
    }
	{{/if}}
}